struct Cell {
	var next : Cell;
	var data : Int;
	var acell : AbsCell;
}

struct AbsCell {
	var anext : AbsCell;
	var adata : Int;
}

struct Result {
	var assigned : Bool;
	var isNull : Bool;
	var value : Int;

	// this is horrible
	var casS : Cell;
	var casAbs : AbsCell;
}

predicate StackInv(X : Set<Cell>, A : Set<AbsCell>, S : Cell, Abs : AbsCell)
requires acc(X) &*& acc(A) {
	A = { z : AbsCell :: Btwn(anext, Abs, z, null) && z != null }
	&& (S == null || S in X)
	&& (Abs == null || Abs in A)
	&& (forall x : Cell ::
		(
			Btwn(next, S, x, null) ==>
				(x in X
				 && x.acell != null
				 && x.acell in A
				 && x.acell.adata == x.data
				 && (x.next != null ==> (x.next in X && x.next.acell == x.acell.anext))
				 && (x.next == null ==> x.acell.anext == null))
		)
	)
}

//procedure StackInv_sat(X : Set<Cell>, A : Set<AbsCell>, S : Cell, Abs : AbsCell)
//requires acc(X) &*& acc(A) &*& StackInv(X, A, S, Abs)
//ensures false
//{
//}

procedure LinThis(this : Result, t : Cell)
requires
	acc(this)
	&*& acc(t)
	&*& !this.assigned
ensures acc(this) &*& acc(t) &*&
	((t != null ==> !this.assigned)
	 && (t == null ==> this.assigned && this.isNull))
{
	if (t == null) {
		this.assigned := true;
		this.isNull := true;
	}
}

procedure CAS(this : Result, S : Cell, t : Cell, x : Cell)
returns (res : Bool)
requires
	acc(this)
ensures
	acc(this)
	&*&
	(   (S == t ==> (this.casS == x))
	 && (S != t ==> (this.casS == S))
	 && (res == (S == t)))
{
	if (S == t) {
		this.casS := x;
		return true;
	} else {
		this.casS := S;
		return false;
	}
}

procedure LinPush(this : Result, cas : Bool, x : Cell, Abs : AbsCell)
requires
	acc(this)
	&*& acc(x)
	&*& (x.next != null ==> acc(x.next))
	&*& (!this.assigned && x.acell == null)
ensures 
	acc(this)
	&*& acc(x)
	&*& (x.next != null ==> acc(x.next))
	&*& (x.acell != null ==> acc(x.acell))
	&*&
	(   (cas ==>
		(true
		 && this.assigned
		 && this.casAbs == x.acell
		 && x.acell != null
		 && x.acell.adata == x.data
		 && (x.next == null ==> x.acell.anext == null)
		 && (x.next != null ==> x.acell.anext == x.next.acell)
		 && !this.isNull
		 && this.value == x.data
		 ))
	 && (!cas ==>
	 	(true
		 && this.casAbs == Abs
		 && !this.assigned
		 && x.acell == null
		 )))
{
	if (cas) {
		this.assigned := true;
		this.isNull := false;
		this.value := x.data;

		x.acell := new AbsCell;
		x.acell.adata := x.data;
		if (x.next != null) {
			x.acell.anext := x.next.acell;
		} else {
			x.acell.anext := null;
		}
		this.casAbs := x.acell;
	} else {
		this.casAbs := Abs;
	}
}

procedure LinPop(this : Result, cas : Bool, x : Cell, Abs : AbsCell)
requires
	acc(this)
	&*& (x != null ==> acc(x))
	&*& (!this.assigned
	     && ((cas && x != null) ==> (x.acell != null && x.acell.adata == x.data)))
ensures 
	acc(this)
	&*& (x != null ==> acc(x))
	&*&
	(   (cas ==>
		(   (x == null ==> this.casAbs == null)
		 && (x != null ==>
		        (this.value = x.data
			 && this.casAbs == x.acell
			 && x.acell.adata == x.data
		        )
		    )
		)
		 && this.assigned
		 && (this.isNull == (x == null)))
	 && (!cas ==>
	 	(   this.casAbs = Abs
		 && !this.assigned)))
{
	if (cas) {
		this.assigned := true;
		if (x != null) {
			this.isNull := false;
			this.value := x.data;
			this.casAbs := x.acell;
		} else {
			this.isNull := true;
			this.casAbs := null;
		}
	} else {
		this.casAbs := Abs;
	}
}


procedure CASThis(this : Result, Abs : AbsCell, S : Cell, t : Cell, x : Cell)
returns (res : Bool)
requires
	acc(this)
	&*& (x != null ==> acc(x))
	&*& (!this.assigned)
ensures 
	acc(this)
	&*& (x != null ==> acc(x))
	&*&
	(   (S == t ==>
		(this.casS == x
		 && (x == null ==> this.casAbs == null)
		 && (x != null ==> this.casAbs == x.acell)
		 && this.assigned
		 && (this.isNull == (x == null))
		 && (x != null ==> this.value = x.data)
		 && res))
	 && (S != t ==>
	 	(this.casS == S
		 && this.casAbs == Abs
		 && !this.assigned
		 && !res)) )
{
	if (S == t) {
		this.casS := x;
		// Ghost code
		this.assigned := true;
		if (x != null) {
			this.isNull := false;
			this.value := x.data;
			this.casAbs := x.acell;
		} else {
			this.isNull := true;
			this.casAbs := null;
		}
		// End ghost code
		return true;
	} else {
		this.casS := S;
		// Ghost code
		this.casAbs := Abs;
		// End ghost code;
		return false;
	}
}

predicate KG(X : Set<Cell>, A : Set<AbsCell>, S : Cell, t : Cell, y : Cell)
requires acc(X) &*& acc(A) &*& (S in X && t in X)
{
	(Btwn(next, S, t, null) ==> t.next == y
	 && (y != null ==>
	         (y in X && y.acell in A && y.acell.adata == y.data)))
}

procedure K_stab(X : Set<Cell>, A : Set<AbsCell>, S : Cell, t : Cell, y : Cell)
requires acc(X) &*& ((y == null || y in X) && KG(X, A, S, t, y))
ensures acc(X) &*& ((y == null || y in X) && KG(X, A, S, t, y))
{}
