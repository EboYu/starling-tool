/* See 'A Lazy Concurrent List-Based Set Algorithm'
   by Heller et al.
   DOI: 10.1007/11795490_3 */

struct Entry {
	var key : Int;
	var next : Entry;
	var marked : Bool;
	var lock : Bool;  // in the original, this is of type Lock.
}

/*
 * Return value properties
 */

predicate removedG(X : Set<Entry>, k : Int) {
	exists e : Entry :: e in X && e.key == k && e.marked == true
}

/*
 * Locks
 */

procedure waitLock(x: Entry)
  requires acc(x)
  ensures acc(x) &*& entryUnlocked(x) {
	assume (x.lock == false);
}

procedure takeLock(x: Entry)
  requires acc(x) &*& entryUnlocked(x)
  ensures acc(x) &*& entryLocked(x) {
	x.lock := true;
}

procedure releaseLock(x: Entry)
  requires acc(x) &*& entryLocked(x)
  ensures acc(x) &*& entryUnlocked(x) {
	x.lock := false;
}

predicate entryLocked(x : Entry) {
	x.lock == true
}

predicate entryUnlocked(x : Entry) {
	x.lock == false
}

predicate has2Locked(x : Entry, y : Entry) {
	x.next == y && x.key < y.key && x.lock == true && y.lock == true
}

/*
 * Validation
 */
function validate(pred : Entry, curr : Entry)
  returns (B : Bool)
  requires acc(pred) &*& acc(curr)
  ensures (
      (B == (!pred.marked && !curr.marked && pred.next == curr))
  );

/*
 * Grasshopper versions of phi predicates
 *
 * These are represented as a single Starling view 'isSet' that is always
 * asserted.
 */

// H has a non-null value (ie. the head value exists)
predicate phiH(X : Set<Entry>, head : Entry)
  requires acc(X) {
	head in X
}

// T has a non-null value (ie. the tail value exists)
predicate phiT(X : Set<Entry>, tail : Entry)
  requires acc(X) {
	tail in X
}

// The tail entry has no successor
predicate phiTnoNext(X : Set<Entry>, tail : Entry)
  requires acc(X) {
	tail.next == null
}

// Every entry other than the tail entry has a successor
predicate phiNext(X : Set<Entry>, tail : Entry)
  requires acc(X) {
	forall z : Entry :: (z in X && z != tail) ==>
		(exists n : Entry :: n in X && z != n && z.next == n)
}

// The key of the tail entry is the upper bound
predicate phiU(X : Set<Entry>, tail : Entry, ub : Int)
  requires acc(X) {
	tail in X ==> tail.key == ub
}

// The key of the head entry is the lower bound
predicate phiL(X : Set<Entry>, head : Entry, lb : Int)
  requires acc(X) {
	head in X ==> head.key == lb
}

// The key of every entry is smaller than the key of its successor
predicate phiLess(X : Set<Entry>)
  requires acc(X) {
	forall z : Entry :: (z in X && z.next != null) ==>
		z.key < z.next.key
}

// The tail entry is reachable from some entry
predicate phiRT_local(X : Set<Entry>, x : Entry, tail : Entry)
  requires acc(X) {
	(x in X && x != tail) ==>
		(exists R : Set<Entry> :: R = { z: Entry :: z in X && Btwn(next, x, z, tail) && z != tail } && Btwn(next, x, tail, tail))
}

// The tail entry is reachable from every entry
predicate phiRT(X : Set<Entry>, tail : Entry)
  requires acc(X) {
	forall x : Entry :: phiRT_local(X, x, tail)
}

// There are no cyclic heap paths in the heap
predicate phiAC(X : Set<Entry>)
  requires acc(X) {
	forall x : Entry ::
		(x in X && (exists y : Entry :: y in X && x.next == y)) ==>
		(x != x.next && (!Btwn(next, x.next, x, x)))
}

predicate sortedList(X : Set<Entry>, x : Entry, y : Entry)
  requires acc(X) {
	(x in X && y in X) ==>
	(forall z : Entry ::
		(z in X
		 && Btwn(next, x, z, y)
		 && Btwn(next, z, y, y)
		 && z != y)
		==> z.key < z.next.key)
}

// Every list of entries is sorted.
predicate phiS(X : Set<Entry>)
  requires acc(X) {
	forall x : Entry, y : Entry ::
	((x in X) ==>
	    (Btwn(next, x, y, y) ==> (x.key <= y.key &&
	    ((x.key == y.key) ==> x == y))))
}

// If an entry is unmarked, it is a backbone node.
predicate phiUB(X : Set<Entry>, head : Entry, tail : Entry)
  requires acc(X) {
	(forall z : Entry :: (z in X && z != head && z != tail)
		==> (z.marked == false ==> Btwn(next, head, z, z)))
}

predicate isSetG(X: Set<Entry>, head : Entry, tail : Entry, lb : Int, ub : Int)
  requires acc(X) {
	lb < ub &&
	head != tail &&
	phiH(X, head) &&
	phiT(X, tail) &&
	phiTnoNext(X, tail) &&
	phiNext(X, tail) &&
	phiU(X, tail, ub) &&
	phiL(X, head, lb) &&
	phiLess(X) &&
	phiRT(X, tail) &&
	phiAC(X) &&
	phiS(X) && 
	phiUB(X, head, tail)
}

/*
 * Sigma predicates are modelled as separate, unasserted views.
 * Here are some helper procedures for some of those predicates:
 */

// n is an exterior entry (and, as this is a view, it can never become backbone)
predicate sigmaE(X : Set<Entry>, head : Entry, tail : Entry, n : Entry)
  requires acc(X) {
        n in X && !(Btwn(next, head, n, tail))
}
