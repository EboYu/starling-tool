include "./lin-stack-module.spl";

procedure pop_C003_000 (
    before_Abs: AbsCell,
    after_Abs: AbsCell,
    before_S: Cell,
    before_t: Cell,
    before_x: Cell,
    after_S: Cell,
    inter_1_S: Cell,
    before_57_1_this: Result,
    inter_0_cas: Bool
)
requires
    exists Foot:Set<Cell>, AFoot:Set<AbsCell>, RFoot:Set<Result> :: (
        acc(Foot) &*& acc(AFoot) &*& acc(RFoot) &*&
        (
            ((StackInv(Foot, AFoot, before_S, before_Abs) ) &&
                ((before_x == null || before_x in Foot) && KG(Foot, AFoot, before_S, before_t, before_x) ) &&
                (before_t in Foot && (before_t.next != null ==> before_t.next in Foot) ) &&
                (before_57_1_this in RFoot && !before_57_1_this.assigned ))
        )
    )
ensures
    exists Foot:Set<Cell>, AFoot:Set<AbsCell>, RFoot:Set<Result> :: (
        acc(Foot) &*& acc(AFoot) &*& acc(RFoot) &*&
        (
	AFoot = { z : AbsCell :: Btwn(anext, after_Abs, z, null) && z != null }
	&& (after_S == null || after_S in Foot && after_Abs == after_S.acell)
	&& (after_Abs == null || after_Abs in AFoot)
	&& (forall x : Cell ::
		(
			((x in Foot && x.next != null) ==> x.next in Foot)
			&&
			(
				Reach(next, after_S, x) ==>
					(x in Foot
					 && x.acell != null
					 && x.acell in AFoot
					 && x.acell.adata == x.data
					 && (x.next != null ==>
					     (x.next in Foot
					      && (!Reach(next, x.next, x))
					      && x.next.acell == x.acell.anext))
					 && (x.next == null ==> x.acell.anext == null))
			)
		)
	)
	)
    )
{
    var shadow_inter_0_cas: Bool;
    shadow_inter_0_cas := CAS(before_57_1_this, before_S, before_t, before_x) ;
    pure assume (inter_0_cas == shadow_inter_0_cas);
    var shadow_inter_1_S: Cell;
    shadow_inter_1_S := before_57_1_this.casS ;
    pure assume (inter_1_S == shadow_inter_1_S);

	if (inter_0_cas) {
		pure assert (inter_1_S == before_x);
		before_57_1_this.assigned := true;
		if (before_x != null) {
			before_57_1_this.isNull := false;
			before_57_1_this.value := before_x.data;
			before_57_1_this.casAbs := before_x.acell;
			pure assert (before_57_1_this.casAbs == inter_1_S.acell);
		} else {
			before_57_1_this.isNull := true;
			before_57_1_this.value := 0;
			before_57_1_this.casAbs := null;
		}
	} else {
		before_57_1_this.casAbs := before_Abs;
	}


    //LinPop(before_57_1_this, inter_0_cas, before_x, before_Abs) ;
    var shadow_after_Abs: AbsCell;
    shadow_after_Abs := before_57_1_this.casAbs ;
    pure assume (after_Abs == shadow_after_Abs);
    pure assume (after_S == inter_1_S);
    pure assert (after_Abs == before_Abs || after_S == null || after_Abs == after_S.acell);
}

