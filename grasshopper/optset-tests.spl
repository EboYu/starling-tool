include "./optset-module.spl";

procedure remove_C016_000 (
    before_curr: Entry,
    before_pred: Entry
)
requires
    exists X:Set<Entry> :: (
        acc(X) &*&
        (
            before_pred in X &&
            before_curr in X &&
            before_pred.next == before_curr &&
            before_pred.key < before_curr.next.key &&
    phiS(X) &&
            (exists n : Entry :: n in X && before_curr != n && before_curr.next == n) &&
            (forall x : Entry ::
                (x in X && (exists y : Entry :: y in X && x.next == y)) ==>
                (x != x.next && (!Btwn(next, x.next, x, x)))) &&
            (forall z : Entry :: (z in X && z.next != null) ==> z.key < z.next.key)
        )
    )
ensures
    exists X:Set<Entry> :: (
        acc(X) &*&
        (
            forall z : Entry :: (z in X && z.next != null) ==> z.key < z.next.key
        )
    )
{
    before_pred.next := before_curr.next ;
}

/*
procedure phiS_stable()
  requires exists X : Set<Entry> :: acc(X) &*& phiS(X)
  ensures exists X : Set<Entry> :: acc(X) &*& phiS(X)
{}

procedure phiUB_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& phiUB(X, head, tail)
  ensures exists X : Set<Entry> :: acc(X) &*& phiUB(X, head, tail)
{}

procedure phiRT_stable(tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& phiRT(X, tail)
  ensures exists X : Set<Entry> :: acc(X) &*& phiRT(X, tail)
{}

procedure phiAC_stable()
  requires exists X : Set<Entry> :: acc(X) &*& phiAC(X)
  ensures exists X : Set<Entry> :: acc(X) &*& phiAC(X)
{}

procedure globalShape_stable(tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& globalShape(X, tail)
  ensures exists X : Set<Entry> :: acc(X) &*& globalShape(X, tail)
{}

procedure globalShape_S_stable(tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& (globalShape(X, tail) && phiS(X))
  ensures exists X : Set<Entry> :: acc(X) &*& (globalShape(X, tail) && phiS(X))
{}

procedure globalShape_UB_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& (globalShape(X, tail) && phiUB(X, head, tail))
  ensures exists X : Set<Entry> :: acc(X) &*& (globalShape(X, tail) && phiUB(X, head, tail))
{}

procedure S_UB_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& (phiS(X) && phiUB(X, head, tail))
  ensures exists X : Set<Entry> :: acc(X) &*& (phiS(X) && phiUB(X, head, tail))
{}

procedure RT_S_UB_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& (phiRT(X, tail) && phiS(X) && phiUB(X, head, tail))
  ensures exists X : Set<Entry> :: acc(X) &*& (phiRT(X, tail) && phiS(X) && phiUB(X, head, tail))
{}

procedure AC_S_UB_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& (phiAC(X) && phiS(X) && phiUB(X, head, tail))
  ensures exists X : Set<Entry> :: acc(X) &*& (phiAC(X) && phiS(X) && phiUB(X, head, tail))
{}

procedure global2_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& (phiAC(X) && phiS(X) && phiUB(X, head, tail) && phiRT(X, tail))
  ensures exists X : Set<Entry> :: acc(X) &*& (phiAC(X) && phiS(X) && phiUB(X, head, tail) && phiRT(X, tail))
{}

procedure isSetG_stable(head : Entry, tail : Entry, lb : Int, ub : Int)
  requires exists X : Set<Entry> :: acc(X) &*& isSetG(X, head, tail, lb, ub)
  ensures exists X : Set<Entry> :: acc(X) &*& isSetG(X, head, tail, lb, ub)
{}

// Grouping of smaller set global shape predicates.
predicate globalRTSUB(X : Set<Entry>, head : Entry, tail : Entry)
  requires acc(X) {
        phiRT(X, tail) && 
        phiS(X) &&
        phiUB(X, head, tail) 
}
procedure globalRTSUB_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& globalRTSUB(X, head, tail)
  ensures exists X : Set<Entry> :: acc(X) &*& globalRTSUB(X, head, tail)
{}

// Grouping of smaller set global shape predicates.
predicate globalRTACUB(X : Set<Entry>, head : Entry, tail : Entry)
  requires acc(X) {
        phiRT(X, tail) && 
        phiAC(X) &&
        phiUB(X, head, tail) 
}
procedure globalRTACUB_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& globalRTACUB(X, head, tail)
  ensures exists X : Set<Entry> :: acc(X) &*& globalRTACUB(X, head, tail)
{}

// Grouping of smaller set global shape predicates.
predicate globalRTACS(X : Set<Entry>, head : Entry, tail : Entry)
  requires acc(X) {
        phiRT(X, tail) && 
        phiAC(X) &&
        phiS(X) 
}
procedure globalRTACS_stable(head : Entry, tail : Entry)
  requires exists X : Set<Entry> :: acc(X) &*& globalRTACS(X, head, tail)
  ensures exists X : Set<Entry> :: acc(X) &*& globalRTACS(X, head, tail)
{}
*/

procedure add_C015_001 (
    before_102_1_key: Int,
    before_lb: Int,
    before_ub: Int,
    before_curr: Entry,
    before_head: Entry,
    before_pred: Entry,
    before_tail: Entry
)
requires
    exists X:Set<Entry> :: (
        acc(X) &*&
        (
            ((isSetG(X, before_head, before_tail, before_lb, before_ub) ) &&
                (before_pred.key < before_102_1_key && before_102_1_key < before_curr.key ) &&
                (before_pred in X && before_curr in X && lockedAndValidatedG(before_pred, before_curr) ) &&
                (before_pred.key < before_curr.next.key ) &&
                (before_curr in X && before_curr != before_tail ) &&
                (before_pred in X && before_pred != before_tail ) &&
                (before_102_1_key < before_ub) &&
                (before_lb < before_102_1_key))

                && (before_pred == before_head || before_pred.marked == false)
        )
    )
ensures
    exists X:Set<Entry> :: (
        acc(X) &*&
        (
            (isSetG(X, before_head, before_tail, before_lb, before_ub))
        )
    )
{
    var e : Entry;
                                        e := new Entry;
                                        pure assume (!Btwn(next, before_curr, e, e));
                                        pure assume (!Btwn(next, e, before_tail, before_tail));
                                        e.key := before_102_1_key;
                                        e.next := before_curr;
                                        e.marked := false;
                                        before_pred.next := e ;
}
