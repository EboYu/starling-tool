include "./lclist-module.spl"; 

// Test that the basic predicates are satisfiable. 

procedure pred_sat_test0 (X: Set<Node>, head: Node) 
  requires lseg(X, head, null)
  ensures false  
{} 

procedure pred_sat_test1 (X: Set<Node>, head: Node, ub: Int) 
  requires isListG(X, head, ub)
  ensures false  
{} 

procedure pred_sat_test2 (X: Set<Node>, head: Node, a: Node, v: Int) 
  requires isValG(X, a, v)
  ensures false  
{} 

procedure pred_sat_test3 (X: Set<Node>, head: Node, a: Node, b: Node) 
  requires has1LockG(X, a, b)
  ensures false  
{} 

procedure pred_sat_test4 (X: Set<Node>, head: Node, a: Node, b: Node, c: Node) 
  requires has2LockG(X, a, b, c)
  ensures false  
{} 

procedure pred_sat_test5 (X: Set<Node>) 
  requires sTrue(X)
  ensures false  
{} 

// Test that conjunctions of predicates are satisfiable. 
// All of these tests should fail. 

procedure conj_sat_test0 (X: Set<Node>, head: Node) 
  requires (
    lseg(X, head, null) 
     && 
    sTrue(X) 
  ) 
  ensures false  
{} 

procedure conj_sat_test1 (X: Set<Node>, head: Node, a: Node, b: Node) 
  requires (
    lseg(X, head, null) 
     && 
    has1LockG(X, a, b) 
  ) 
  ensures false  
{} 

procedure conj_sat_test2 (X: Set<Node>, head: Node, a: Node, b: Node, c: Node) 
  requires (
    lseg(X, head, null) 
     && 
    has2LockG(X, a, b, c) 
  ) 
  ensures false  
{} 

procedure conj_sat_test3 (X: Set<Node>, head: Node, a: Node, v: Int) 
  requires (
    lseg(X, head, null) 
     && 
    isValG(X, a, v) 
  ) 
  ensures false  
{} 


// Spatial true tests

procedure sTrue_test(X: Set<Node>, a: Int, b:Int) 
  requires ((a=b) &*& sTrue(X)) || ((a!=b) &*& sTrue(X)) 
  ensures sTrue(X) 
{ }  

procedure sTrue_test3(X: Set<Node>) 
  requires sTrue(X) && sTrue(X) 
  ensures sTrue(X) && sTrue(X) 
{ }  

procedure sTrue_test4(X: Set<Node>) 
  requires sTrue(X) && sTrue(X) 
  ensures sTrue(X) 
{ }  

procedure sTrue_test5 (a: Node, b: Node) 
  requires acc(a) &*& acc(b)
  ensures (exists X : Set<Node> :: sTrue(X)) 
{} 

// Tests of overlap (+) and inclusion (-**) 

procedure inclusion_test (X: Set<Node>, a: Node) 
  requires acc(X) &*& a in X 
  ensures acc(a) -** acc(X)  
{} 

procedure sharing_test (X: Set<Node>, a: Node, b: Node) 
  requires acc(a) && acc(b)
  ensures (acc(a) &*& acc(b)) || acc(a) 
{}


// Lock tests 

procedure lock_test0 (X: Set<Node>, a: Node, b: Node) 
  requires has1LockG(X, a, b)
  ensures acc(a) -** sTrue(X)  
{} 

procedure lock_test1 (X: Set<Node>, a: Node, b: Node, c: Node) 
  requires (
    has1LockG(X, a, b) && 
    has1LockG(X, b, c)
  ) 
  ensures has2LockG(X, a, b, c)   
{} 

procedure lock_sat_test1 (X: Set<Node>, a: Node, b: Node, c: Node) 
  requires (
    has1LockG(X, a, b) && 
    has1LockG(X, b, c)
  ) 
  ensures false   
{} 


// requires conjunction test

procedure test_req (a: Node, b: Node) 
  requires acc(a) &*& (exists X : Set<Node> :: sTrue(X)) 
  requires acc(a) &*& acc(b)
  ensures acc(a) &*& acc(b) 
{} 


// Simple program tests

procedure takeLock_test (X: Set<Node>, head: Node, ub: Int, a: Node, b: Node, v: Int) 
  requires (
    isListG(X, head, ub) && 
    has1LockG(X, a, b) && 
    isValG(X,a,v) && 
    (sTrue(X) &*& v < ub) 
  ) 
  ensures  
    exists c: Node :: has2LockG(X, a, b, c) 
{ 
   takeLock(b); 
} 

procedure takeLock_sat_test (X: Set<Node>, head: Node, ub: Int, a: Node, b: Node, v: Int) 
  requires (
    isListG(X, head, ub) && 
    has1LockG(X, a, b) && 
    isValG(X,a,v) && 
    (sTrue(X) &*& v < ub) 
  ) 
  ensures  
    false
{ 
   takeLock(b); 
} 

