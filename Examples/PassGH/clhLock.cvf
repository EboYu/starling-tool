typedef int Node;

pragma grasshopper_include {./grasshopper/CLHlock-module.spl};
pragma grasshopper_footprint {Foot};
pragma grasshopper_footprint_sort {Set<Node>};

shared Node head, tail;

thread Node mynode, mypred;
thread bool test;  // Used when trying to take the lock.

view loose(Node x, bool isLocked);
view queued(Node x, Node xp);
view holdLock(Node x, Node xp);

method lock(Node mynode) {
  {| loose(mynode, false) |}
    < %{ [|mynode|].lock := true } >;
  {| loose(mynode, true) |}
    <{ mypred = tail;
       tail = mynode;
       %{[|tail|].pred := [|mypred|]}; }>;  // Ghost code
  {| queued(mynode, mypred) |}
    do {
      {| queued(mynode, mypred) |}
        test = %{ [|mypred|].lock };
      {| if test then queued(mynode, mypred) else holdLock(mynode, mypred) |}
    } while (test);
  {| holdLock(mynode, mypred) |}
}

method unlock(Node mynode, Node mypred) {
  {| holdLock(mynode, mypred) |}
    <{ %{ [|mynode|].lock := false };
       %{ [|mynode|].pred := null };  // Ghost code
       head = mynode;  // Ghost code
       }>;
  {| loose(mypred, false) |}
    mynode = mypred;
  {| loose(mynode, false) |}
}

constraint emp -> %{ CLHfoot(Foot, [|head|], [|tail|]) };

constraint queued(a, ap) -> %{ queuedG(Foot, [|a|], [|head|], [|tail|], [|ap|]) };
constraint queued(a, ap) * queued(b, bp) -> a != b;

// Loose means the node is unlinked from the queue.
constraint loose(a, l) -> %{ looseG(Foot, [|a|], [|head|]) && [|a|].lock == [|l|] };
constraint loose(a, al) * loose(b, bl) -> a != b;
// loose and queued are contradictory by definition

constraint holdLock(a, ap) -> %{ queuedG(Foot, [|a|], [|head|], [|tail|], [|ap|]) && [|ap|] == [|head|] };

constraint holdLock(a, ap) * queued(b, bp) -> a != b;
constraint holdLock(a, ap) * holdLock(b, bp) -> false;

