typedef int Lock;  
typedef bool Bool;  

pragma grasshopper_include {./grasshopper/spinlock-module.spl};
pragma grasshopper_footprint {LockF};
pragma grasshopper_footprint_sort {Set<Lock>};

shared int heap; 

thread Lock x, ret;  
thread Bool test;  // Used when trying to take the lock.

view holdLock(Lock x);
view isLock(Lock x); 

method newLock() { 
  {| emp |} 
    ret = %{new Node}(); 
  {| isLock(ret) |} 
    <%{#1.lock := false}(ret)[heap]>;
  {| isLock(ret) |} 
} 

method lock(Lock x) {
  {| isLock(x) |}
    do {
      {| isLock(x) |}
        test = false;
      {| if test == false then isLock(x) else False() |}
        test = %{ CAS_to_true(#1) }(x);
      {| if test == false then isLock(x) else holdLock(x) |}
    } while (test == true);
  {| holdLock(x) |}
}

method unlock(Lock x) {
  {| holdLock(x) |}
    <%{#1.lock := false}(x)[heap]>;
  {| isLock(x) |}
}

method split(Lock x) { 
  {| isLock(x) |} 
    ; 
  {| isLock(x) * isLock(x) |} 
} 

// False is a hack to implement local variable reasoning.
view False();
constraint False() -> false;

constraint holdLock(x) * holdLock(y) -> x != y; 

constraint holdLock(x)  ->  %{ #1 in LockFoot && #1.lock == true }(x); 

constraint isLock(x)  ->  %{ #1 in LockFoot }(x); 

