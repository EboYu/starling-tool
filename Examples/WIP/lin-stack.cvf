/* The non-blocking stack algorithm seen on page 87 of Viktor Vafeiadis's
   thesis (Treiber?). */

typedef int Cell;
typedef int AbsCell;
typedef int Result;

pragma grasshopper_include {./grasshopper/lin-stack-module.spl};
pragma grasshopper_footprint {Foot};
pragma grasshopper_footprint_sort {Set<Cell>};
pragma grasshopper_footprint {AFoot};
pragma grasshopper_footprint_sort {Set<AbsCell>};
pragma grasshopper_footprint {RFoot};
pragma grasshopper_footprint_sort {Set<Result>};

shared Cell S;

shared AbsCell Abs; // ghost code

thread Cell t, x;
thread int temp;
thread Cell v;
thread bool cas;

// StackInv becomes emp, as K => StackInv.
view K(Cell t, Cell c);
view ExistsK(Cell t);
view NoAbsResult(Result r);
view AbsResult(Result r, int k);
view SomeAbsResult(Result r);
view NullAbsResult(Result r);  // ideally this should be part of AbsResult.
view LocalCell(Cell c, int v);
view MaybeTop(Cell c);
view PendingCell(Cell c, int v, Cell n);

// We're having to push in the cell separately to avoid allocation weirdness.
method push(int v, Cell x, Result this /* ghost code */) {
    {| NoAbsResult(this) * LocalCell(x, v) |}
/*        // TODO(MattWindsor91): this should probably not be atomic.
        <{ x = %{ new Cell };
           %{ [|x|].next := null };  // This needs to be explicit for this proof
           %{ [|x|].acell := null };
           %{ [|x|].data := [|v|] }; }>;
    {| NoAbsResult(this) * LocalCell(x, v) |} */
        do {
            {| NoAbsResult(this) * LocalCell(x, v) |}
                < t = S >;
            {| NoAbsResult(this) * LocalCell(x, v) * MaybeTop(t) |}
                < %{ [|x|].next := [|t|] } >;
            {| NoAbsResult(this) * PendingCell(x, v, t) |}
                <{ cas = %{ CAS([|this|], [|S|], [|t|], [|x|]) };
                   S = %{ [|this|].casS };
                   %{ LinPush([|this|], [|cas|], [|x|], [|Abs|]) };
                   Abs = %{ [|this|].casAbs };
                 }>;
            {| if cas
               then AbsResult(this, v)
               else NoAbsResult(this) * LocalCell(x, v) |}
        } while (!cas);
    {| AbsResult(this, v) |}
}

method pop(Result this /* ghost code */) {
    {| NoAbsResult(this) |}
        do {
            {| NoAbsResult(this) |}
                <{ t = S;
                   %{ LinThis([|this|], [|t|]) };  // slight change to move '= null' into GH
                 }>;
            {| if (t == %{ null })
               then NullAbsResult(this)
               else NoAbsResult(this) * MaybeTop(t) * ExistsK(t) |}
                // TODO(MattWindsor91: model returns properly
                < assume(t != %{ null }) >;
            {| NoAbsResult(this) * MaybeTop(t) * ExistsK(t) |}
                < x = %{ [|t|].next } >;
            {| NoAbsResult(this) * MaybeTop(t) * K(t, x) |}
                // This is an attempt to get round the fact that the Starling
                // CAS is limited to integers and Booleans, and the GRASShopper
                // CAS can't modify S.
                <{ cas = %{ CAS([|this|], [|S|], [|t|], [|x|]) };
                   S = %{ [|this|].casS };
                   %{ LinPop([|this|], [|cas|], [|x|], [|Abs|]) };
                   Abs = %{ [|this|].casAbs };
                 }>;
            {| if cas
               // TODO(MattWindsor91): an existential would help here.
               // We'd be able to avoid making such a huge view.
               then SomeAbsResult(this) * MaybeTop(t)
               else NoAbsResult(this) |}
        } while (!cas);
    {| SomeAbsResult(this) * MaybeTop(t) |}
        < temp = %{ [|t|].data } >;
    {| AbsResult(this, temp) |}
}

// StackInv
constraint emp -> %{ StackInv(Foot, AFoot, [|S|], [|Abs|]) };

constraint K(t, y) ->
    %{ ([|y|] == null || [|y|] in Foot) && KG(Foot, AFoot, [|S|], [|t|], [|y|]) };
constraint ExistsK(t) ->
    %{ Btwn(next, [|S|], [|t|], null) ==> ([|t|].next == null || [|t|].next in Foot) };

constraint NoAbsResult(a) -> %{ [|a|] in RFoot && ![|a|].assigned };
constraint AbsResult(a, x) ->
    %{ [|a|] in RFoot && [|a|].assigned && ![|a|].isNull && [|a|].value == [|x|] };
constraint NullAbsResult(a) ->
    %{ [|a|] in RFoot && [|a|].assigned && [|a|].isNull };
constraint SomeAbsResult(a) ->
    %{ [|a|] in RFoot && [|a|].assigned && ![|a|].isNull };

constraint MaybeTop(x) ->
    %{ [|x|] in Foot };

constraint LocalCell(x, v) ->
    %{ [|x|] in Foot
       && [|x|] != [|S|]
       && [|x|].acell == null
       && [|x|].next == null
       && [|x|].data == [|v|]
       && (forall y : Cell :: (y in Foot ==> y.next != [|x|])) };
constraint LocalCell(x, vx) * LocalCell(y, vy) -> x != y;

constraint PendingCell(x, v, y) ->
    %{ [|x|] in Foot
       && [|y|] in Foot
       && [|x|] != [|S|]
       && [|x|].acell == null
       && [|x|].next == [|y|]
       && [|x|].data == [|v|]
       && (forall z : Cell :: (z in Foot ==> z.next != [|x|])) };
constraint LocalCell(x, vx) * PendingCell(y, vy, ny) -> x != y;
constraint PendingCell(x, vx, nx) * PendingCell(y, vy, ny) -> x != y;

// AbsResults are unique to a method call.
constraint NoAbsResult(a)   * NoAbsResult(b)    -> a != b;
constraint AbsResult(a, x)  * NoAbsResult(b)    -> a != b;
constraint AbsResult(a, x)  * AbsResult(b, y)   -> a != b;
constraint NullAbsResult(a) * NoAbsResult(b)    -> a != b;
constraint NullAbsResult(a) * AbsResult(b, y)   -> a != b;
constraint NullAbsResult(a) * NullAbsResult(b)  -> a != b;
constraint SomeAbsResult(a) * NoAbsResult(b)    -> a != b;
constraint SomeAbsResult(a) * AbsResult(b, y)   -> a != b;
constraint SomeAbsResult(a) * NullAbsResult(b)  -> a != b;
constraint SomeAbsResult(a) * SomeAbsResult(b)  -> a != b;
