typedef int Node;

pragma grasshopper_include {./grasshopper/CLHlock-module.spl};
pragma grasshopper_footprint {Foot};
pragma grasshopper_footprint_sort {Set<Node>};

shared Node head, tail;

thread Node mynode, mypred;
thread bool test;  // Used when trying to take the lock.

view isMyNode(Node x);
view isActive(Node x);
view loose(Node x);
view queued(Node x);
view holdLock(Node x);

method lock(Node mynode) {
  {| loose(mynode) |}
    < %{ #1.lock := true }(mynode)[] >;
  {| isActive(mynode) * loose(mynode) |}
    <{ mypred = tail;
       tail = mynode;
       %{#1.pred := #2}(tail, mypred)[]; }>;  // Ghost code
  {| isMyNode(mynode) * isActive(mynode) * queued(mypred) |}
    do {
      {| isMyNode(mynode) * isActive(mynode) * queued(mypred) |}
        test = %{ #1.lock }(mypred);
      {| isMyNode(mynode) * queued(mypred)
         * if !test then holdLock(mynode) else isActive(mynode) |}
    } while (test);
  {| isMyNode(mynode) * holdLock(mynode) * queued(mypred) |}
}

method unlock(Node mynode, Node mypred) {
  {| isMyNode(mynode) * holdLock(mynode) * queued(mypred) |}
    <{ %{ #1.lock := false }(mynode)[];
       %{ #1.pred := null }(mynode)[]; // ghost code
       head = mynode;
       }>; // ghost code
  {| queued(mypred) |}
    mynode = mypred;
  {| isMyNode(mynode) |}
}

constraint emp -> %{ CLHfoot(Foot, #1, #2) }(head, tail);

constraint isMyNode(a) -> %{ #1 in Foot }(a);
constraint isMyNode(a) * isMyNode(b) -> a != b;

constraint queued(a) -> %{ #1 in Foot && #1 != #2 && Btwn(pred, #3, #1, #2) }(a, head, tail);

// Loose means the node is unlinked from the queue.
constraint loose(a) -> %{ #1 in Foot && #1 != #2 && #1 != #3 && #1.pred == null && (forall x : Node :: x in Foot ==> !Reach(pred, x, #1)) }(a, tail, head);
constraint loose(a) * loose(b) -> a != b;
constraint loose(a) * isMyNode(b) -> a != b;

constraint isActive(a) -> %{ #1 in Foot && #1.lock == true }(a);

constraint holdLock(a) -> %{ #1 in Foot && #1.lock == true && #1.pred != null && #1.pred.lock == false && #1.pred == #2 }(a, head);

constraint holdLock(a) * holdLock(b) -> false;

