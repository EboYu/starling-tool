typedef int Node;

pragma grasshopper_include {./grasshopper/CLHlock-module.spl};
pragma grasshopper_footprint {Foot};
pragma grasshopper_footprint_sort {Set<Node>};

shared Node head, tail;

thread Node mynode, mypred;
thread bool test;  // Used when trying to take the lock.

view active(Node x);
view loose(Node x);
view queued(Node x, Node xp);
view holdLock(Node x, Node xp);

method lock(Node mynode) {
  {| loose(mynode) |}
    < %{ #1.lock := true }(mynode)[] >;
  {| active(mynode) |}
    <{ mypred = tail;
       tail = mynode;
       %{#1.pred := #2}(tail, mypred)[]; }>;  // Ghost code
  {| queued(mynode, mypred) |}
    do {
      {| queued(mynode, mypred) |}
        test = %{ #1.lock }(mypred);
      {| if test then queued(mynode, mypred) else holdLock(mynode, mypred) |}
    } while (test);
  {| holdLock(mynode, mypred) |}
}

method unlock(Node mynode, Node mypred) {
  {| holdLock(mynode, mypred) |}
    <{ %{ #1.lock := false }(mynode)[];
       %{ #1.pred := null }(mynode)[]; // ghost code
       head = mynode;
       }>; // ghost code
  {| loose(mypred) |}
    mynode = mypred;
  {| loose(mynode) |}
}

constraint emp -> %{ CLHfoot(Foot, #1, #2) }(head, tail);

constraint queued(a, ap) -> %{ queuedG(Foot, #1, #2, #3, #4) }(a, head, tail, ap);
constraint queued(a, ap) * queued(b, bp) -> a != b;

// Loose means the node is unlinked from the queue.
constraint loose(a) -> %{ looseG(Foot, #1, #2, #3) && !#1.lock }(a, head, tail);
constraint loose(a) * loose(b) -> a != b;
// loose and queued are contradictory by definition

constraint active(a) -> %{ looseG(Foot, #1, #2, #3) && #1.lock }(a, head, tail);
constraint active(a) * active(b) -> a != b;
constraint active(a) * loose(b) -> a != b;
// active and queued are contradictory by definition

constraint holdLock(a, ap) -> %{ queuedG(Foot, #1, #2, #3, #4) && #4 == #2 }(a, head, tail, ap);

constraint holdLock(a, ap) * queued(b, bp) -> a != b;
constraint holdLock(a, ap) * loose(b) -> ap != b;

constraint holdLock(a, ap) * holdLock(b, bp) -> false;

