pragma grasshopper_include {./grasshopper/optset-module.spl};
pragma grasshopper_footprint {X};
pragma grasshopper_footprint_sort {Set<Entry>};

typedef int Entry;
typedef int Int;
typedef bool Bool;

shared Entry head, tail;
shared Int ub, lb;

thread Bool present, done;
thread Int ckey;
thread Entry pred, curr;

view isHead(Entry h), isTail(Entry t), isEntry(Entry t), isEntryOrTail(Entry t);
view keyIs(Int k, Entry e), isMarked(Entry e), isExterior(Entry e);
view wf(Int key);
view less(Entry x, Entry y);

view hasLock(Entry p), has2Lock(Entry p, Entry q);

view removed(Int k);

method remove(Int key) {
    {| wf(key) |}
        do {
            {| wf(key) |}
                <pred = head>;
            {| wf(key) * isHead(pred) |}
                curr = %{ #1.next }(pred);
            {| wf(key) * isHead(pred)
               * isEntryOrTail(curr)  // Set could be empty -> curr==tail.
            |}
                ckey = %{ #1.key }(curr);
            {| wf(key) * isHead(pred) * isEntryOrTail(curr)
               * keyIs(ckey, curr)  // We just read it, and it never changes.
            |}
                while (ckey < key) {
                    {| wf(key)
                       * isEntry(curr)  // If this was tail, ckey > key.
                       // Throw everything else away because we're
                       // re-establising it below.
                    |}
                        pred = curr;
                    {| wf(key) * isEntry(pred) * isEntry(curr) |}
                        curr = %{ #1.next }(pred);
                    {| wf(key) * isEntry(pred)
                       * isEntryOrTail(curr) // See above.
                    |}
                        ckey = %{ #1.key }(curr);
                    {| wf(key) * isEntry(pred) * isEntryOrTail(curr)
                       * keyIs(ckey, curr)  // See above.
                    |}
                }
            {| wf(key) * isEntry(pred) * isEntryOrTail(curr) * keyIs(ckey, curr) |}
                <%{ waitLock(#1); takeLock(#1) }(pred)[]>;
            {| wf(key) * hasLock(pred) * isEntryOrTail(curr) * keyIs(ckey, curr) |}
                <%{ waitLock(#1); takeLock(#1) }(curr)[]>;
            {| wf(key) * hasLock(pred) * hasLock(curr) * keyIs(ckey, curr) |}
                if (%{ validate(#1, #2) == true }(pred, curr)) {
                    {| wf(key) * has2Lock(pred, curr) * keyIs(ckey, curr) * less(pred, curr) |}
                        if (ckey != key) {
                            {| wf(key) * has2Lock(pred, curr) |}
                                present = false;
                                done = true;
                            {| wf(key) * hasLock(pred) * hasLock(curr) * if present == true then removed(key) else emp |}
                        } else {
                            {| wf(key)
                               * isEntry(curr)  // from wf(key) and ckey == key
                               * has2Lock(pred, curr)
                               * less(pred, curr)
                               * keyIs(key, curr)
                            |}
                                <%{ #1.marked := true }(curr)[]>;
                            {| wf(key) * isEntry(curr) * has2Lock(pred, curr) * less(pred, curr)
                               * isMarked(curr)  // From the previous action
                               * removed(key)    // From the previous action
                               // phiLess and isEntry should imply that
                               // less(pred, curr.next).
                               // TODO: they don't.
                            |}
                                <%{ #1.next := #2.next }(pred, curr)[]>;
                            {| wf(key) * hasLock(pred) * hasLock(curr) * removed(key)
                               // We've used less now so we no longer need it.
                            |}
                                present = true;
                                done = true;
                            {| wf(key) * hasLock(pred) * hasLock(curr) * if present == true then removed(key) else emp |}
                        }
                    {| wf(key) * hasLock(pred) * hasLock(curr) * if present == true then removed(key) else emp |}
                } else {
                    {| wf(key) * hasLock(pred) * hasLock(curr) |}
                        // We shouldn't need to do this...?
                        present = false;
                        done = false;
                    {| wf(key) * hasLock(pred) * hasLock(curr) * if present == true then removed(key) else emp |}
                }     
            {| wf(key) * hasLock(pred) * hasLock(curr) * if present == true then removed(key) else emp |}
                <%{ releaseLock(#1) }(curr)[]>;
            {| wf(key) * hasLock(pred) * if present == true then removed(key) else emp |}
                <%{ releaseLock(#1) }(pred)[]>;
            {| wf(key) * if present == true then removed(key) else emp |}
        } while (done == false);
    {| if present == true then removed(key) else emp |}
}

// The invariant is 'isSetG', which conjoins all the phi-predicates.
constraint emp -> %{ isSetG(X, #1, #2, #3, #4) }(head, tail, lb, ub);

// A key is wf if it is between the bounds.
constraint wf(key) -> lb < key && key < ub;

// This view encodes sigmaH.
constraint isHead(h) -> h == head;

// This view encodes sigmaT.
constraint isTail(t) -> t == tail;

constraint isEntry(e) -> %{ #1 in X && #1 != #2 }(e, tail);
constraint isEntryOrTail(e) -> %{ #1 in X }(e);

// This view encodes sigmaK.
constraint keyIs(k, n) -> %{ #1 in X ==> #1.key == #2 }(n, k);

// This view encodes sigmaM.
constraint isMarked(n) -> %{ #1 in X ==> #1.marked == true }(n);

// This view encodes sigmaE.
constraint isExterior(n) -> %{ sigmaE(X, #1, #2, #3) }(head, tail, n);

constraint less(x, y) -> %{ #1.key < #2.key }(x, y);

constraint removed(k) -> %{ removedG(X, #1) }(k);

constraint hasLock(a)       ->  %{ #1 in X && entryLocked(#1) }(a);
constraint has2Lock(a, b)   ->  %{ #1 in X && #2 in X && has2Locked(#1, #2) }(a, b);

constraint hasLock(a)      * hasLock(b)       ->  a != b;
constraint hasLock(a)      * has2Lock(b, c)   ->  a != b && a != c;
constraint has2Lock(a, b)  * has2Lock(c, d)   ->  a != c && a != d && b != c && b != d;
